1. Intro - Innovations in React and Flux
===================

* Unique qualities React has to offer:
  - JSX - writing markup (HTML) in JavaScript.
  - Virtual DOM - minimizes expensive updates to the DOM. React => Virtual DOM => DOM.
                When UI changes, React compares the old state with the new state in memory and ten updates the DOM in the least expensive way.
  - Isomorphic Rendering - allows to render the React components on both Client and Server.
  - Unidirectional Flows (Flux) - data flows are handled in a single direction using the centralized dispatcher.

* React and Flux deliberately ignore some commonly held best practices:
  - HTML should be a projection of app state, not a source of truth, i.e. data shouldn't be stored in DOM.
  - JavaScript and HTML belong in the same file (JSX).
  - Unidirectional flow. No two-way binding.
  - Inline styles can be good.



2. Environment Setup
===================

>npm init
>npm install --save gulp@3.9.0 gulp-connect@2.2.0 gulp-open@1.0.0
>npm install --save browserify@11.0.1 reactify@1.1.1 vinyl-source-stream@1.1.0
>npm install --save bootstrap@3.3.5 jquery@2.1.4 gulp-concat@2.6.0
>npm install --save gulp-eslint@0.15.0
>npm install --save react@0.13.3 react-router@0.13.3 flux@2.0.3
>npm install --save lodash
>npm install --save toastr@2.1.0
>npm install --save object-assign
>npm run gulp


package.json
----
{
  "name": "react-flux-building-applications",
  "version": "1.0.0",
  "description": "Building Applications with React and Flux Pluralsight course by Cory House",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "gulp": "gulp"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/RockingChewee/react-flux-building-applications.git"
  },
  "author": "Aleksandr Fokin",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/RockingChewee/react-flux-building-applications/issues"
  },
  "homepage": "https://github.com/RockingChewee/react-flux-building-applications#readme",
  "dependencies": {
    "bootstrap": "^3.3.5",
    "browserify": "^11.0.1",
    "flux": "^2.0.3",
    "gulp": "^3.9.0",
    "gulp-concat": "^2.6.0",
    "gulp-connect": "^2.2.0",
    "gulp-eslint": "^0.15.0",
    "gulp-open": "^1.0.0",
    "jquery": "^2.1.4",
    "lodash": "^4.17.4",
    "object-assign": "^4.1.1",
    "react": "^0.13.3",
    "react-router": "^0.13.3",
    "reactify": "^1.1.1",
    "toastr": "^2.1.0",
    "vinyl-source-stream": "^1.1.0"
  }
}


gulpfile.js
----
"use strict";

var gulp = require('gulp');
var connect = require('gulp-connect'); // Runs a local dev server
var open = require('gulp-open'); // Opens a URL in a web browser
var browserify = require('browserify'); // Bundles JS, uses CommonJS package pattern
var reactify = require('reactify'); // Transforms React JSX to JS
var source = require('vinyl-source-stream'); // Use conventional text streams with Gulp
var concat = require('gulp-concat'); // Concatinates files
var lint = require('gulp-eslint'); // Lint JS files, including JSX

var config = {
    devBaseUrl: 'http://localhost',
    port: 9005,
    paths: {
        html: './src/*.html',
        js: './src/**/*.js',
        css: [
          'node_modules/bootstrap/dist/css/bootstrap.min.css',
          'node_modules/bootstrap/dist/css/bootstrap-theme.min.css'
        ],
        dist: './dist',
        mainJs: './src/main.js'
    }
}

// Start a local development server
gulp.task('connect', function() {
  connect.server({
    root: ['dist'],
    base: config.devBaseUrl,
    port: config.port,
    livereload: true
  });
});

gulp.task('open', ['connect'], function() {
  gulp.src('dist/index.html')
    .pipe(open({ uri: config.devBaseUrl + ':' + config.port + '/'}));
});

gulp.task('html', function() {
  gulp.src(config.paths.html)
    .pipe(gulp.dest(config.paths.dist))
    .pipe(connect.reload());
});

gulp.task('js', function() {
  browserify(config.paths.mainJs)
    .transform(reactify)
    .bundle()
    .on('error', console.error.bind(console))
    .pipe(source('bundle.js'))
    .pipe(gulp.dest(config.paths.dist + '/scripts'))
    .pipe(connect.reload());
});

gulp.task('css', function() {
  gulp.src(config.paths.css)
    .pipe(concat('bundle.css'))
    .pipe(gulp.dest(config.paths.dist + '/css'));
});

gulp.task('lint', function() {
  return gulp.src(config.paths.js)
    .pipe(lint({config: 'eslint.config.json'}))
    .pipe(lint.format());
});

gulp.task('watch', function() {
  gulp.watch(config.paths.html, ['html']);
  gulp.watch(config.paths.js, ['js', 'lint']);
});

gulp.task('default', ['html', 'js', 'css', 'lint', 'open', 'watch']);


index.HTML
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pluralsight Administration</title>
    <link rel="stylesheet" href="css/bundle.css" />
  </head>
  <body>
    <div class="jumbotron">
      <h1>Hello world from Bootstrap</h1>
    </div>
    <div id="app"></div>
    <script src="scripts/bundle.js"></script>
  </body>
</html>


main.js
----
$ = jQuery = require('jquery'); // Bootstrap expects jquery to be in a global namespace

var App = console.log('Hello world from Browserify');

module.exports = App;


eslint.config.json - http://github.com/coryhouse/react-flux-starter-kit/blob/master/eslint.config.json
----
{
  "root": true,
  "ecmaFeatures": {
    "jsx": true
  },
  "env": {
    "browser": true,
    "node": true,
    "jquery": true
  },
  "rules": {
    "quotes": 0,
    "no-trailing-spaces": 0,
    "eol-last": 0,
    "no-unused-vars": 0,
    "no-underscore-dangle": 0,
    "no-alert": 0,
    "no-lone-blocks": 0
  },
  "globals": {
    "jQuery": true,
    "$": true
  }
}


.editorconfig
----
#editorconfig.org
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false



3. React Core Concepts
===================

* Why React?
  - Fast - Virtual DOM
  - Composable - nested components, data passing via props
  - Pluggable - easily integrated with other technologies
  - Isomorphic Friendly - rendering may happen on both client or server
  - Simple - API is small and moving parts are not a lot
  - Battle Proven - used by Facebook and lot of others

* React and MVC
  - In actuality, a well composed React components fulfil both V and C, called Controller Views.
    Controller Views promote reuse and separation of concern.

* The risk of two-way binding (used by alternatives e.g. Knockout, Angular, ember)

  Simply put, when UI change, a corresponding model change needs to be triggered and vise versa - a model change needs to be reflected in UI.
  These are hard to predict and follow in a complex applications.

  - Pros
    ~ Simple way to eliminate boiler plate
    ~ Quickly deliver applications

  - Cons
    ~ Unpredictable interactions
    ~ Cascading updates
    ~ Tricky debugging

* JSX
  - "HTML" in JavaScript - this is not actual HTML, but it compiles down to JavaScript, which produces HTML
  - Defferences: 'className' instead of 'class', 'htmlFor' instead of 'for'
  - Optional - there is no enforcement to use it, can just use JavaScript instead
  - Example: <h1 color="red">Heading here</h1>  ==> React.createElement("h1", {color: red}, "Heading here")
  - JSX-friendly editors: Sublime (plugin), WebStorm, Brackets, Atom, Visual Studio 2015, VSCode

* HTML in JS: A Justification
  - The popular mindset is to inject JS into HTML (Knockout, Angular, ember) and React does the exact opposite - injects HTML into JS.
    In other words, from architecture point of view this is not very different.
  - HTML and JS must be carefully kept in sync, but there is no explicit interface between HTML and JavaScript to with regards to separation of concerns.
  - In JS we enjoy the clear error messages, which point us to the line number where the error occurred, but HTML usually silently fails.
  - The conclusion is that HTML and JS are totally intertwined concerns and putting them into separate files fails to really separate them.

* Understanding of Virtual DOM

  - Story:
    It is a lot of work for photo-stage setup to put all the lights to the correct spot. When the setup slightly changes, it is much more efficient
    to just move some lights around, rather than tearing them down and blindly rebuilding the stage from scratch.

  - Behind the scenes:
    ~ React compares the current state of the DOM to the new desired state and determines the most efficient way to update the physical DOM.
    ~ The comparison happens in-memory, so it is typically very fast.
    ~ React monitors each component state.

  - Performance tweaks:
    ~ By declaring shouldComponentUpdate() method in React components, which may contain manual logic considering whether to update the DOM even if the model changes.
    ~ PureRenderMixin + immutability - allows reference comparisons
    ~ Synthetic Events - React may optimize the way event handlers are attached behind the scenes
    ~ Isomorphic Support - rendering may be done on a server (will not be covered in this course)
    ~ React Native - since React abstracts the DOM, it can be used for Native (mobile) applications (will not be covered in this course)



4. Creating React Components
===================

* Creating of React component in ES5: React.createClass() {}
* Each react component has to have a render() function. This function returns the JSX that is to be visible on the screen.
  This function may not return 2 elements on the top level, i.e. if 2 are needed - those must be wrapped into single top level element, e.g. div.
* The React.render() has to be invoked in the main js file in order to inject the React components into main html.
  This method accepts the component name that is the highest in hierarchy and a DOM element, to which this component needs to be attached to.
* To workaround the defining of the jquery variable in the global namespace and usage of 'use strict' the IIFE can be used.
  In this case, the main js logic is wrapped into the IIFE and the first line inside the IIFE is 'use strict'.
  IIFE - an Immediately-Invoked Function Expression, which executes immediately after itâ€™s created and  looks like (function(){...})().
* Naming React Files:
  - ChatApp.react.js
  - ChatApp.jsx
  - ChatApp.js
  Preferable approach is to use .js extension, since this appears to be least confusing for the operating systems and JS IDE's to correctly recognize those files.


src/components/homePage.js
----
"use strict";

var React = require('react');

var Home = React.createClass({
  render: function() {
    return (
      <div className="jumbotron">
        <h1>Pluralsight Administration</h1>
        <p>React, React Router, and Flux for ultra-responsive web apps.</p>
      </div>
    );
  }
});

module.exports = Home;


src/main.js
----
//"use strict"; // Cannot 'use strict' here due to the need of having the jquery variable in a global namespace. This is workarounded by using IIFE.
$ = jQuery = require('jquery'); // Bootstrap expects jquery to be in a global namespace

var React = require('react');
var Home = require('./components/homePage');
var About = require('./components/about/aboutPage');
var Header = require('./components/common/header');

(function(win) { // an IIFE to workaround the 'use strict' and jquery global variable collision

  "use strict";

  var App = React.createClass({
    render: function() {
      var Child;
      switch(this.props.route) { // capturing the attribute values passed over by the parent component (this.props)
        case 'about': Child = About; break;
        default: Child = Home;
      }

      return (
        <div>
          <Header/>
          <Child/>
        </div>
      );
    }
  });

  function render() {
    var route = win.location.hash.substr(1); // 'window' to 'win', since 'win' is passed to the IIFE
    React.render(<App route={route} />, document.getElementById('app')); // passing props to the child component
  }

  win.addEventListener('hashchange', render); // Event that occurres when there is a hash change in the URL, e.g. http://localhost:9005/#about
  render();

})(window);


src/index.html
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pluralsight Administration</title>
    <link rel="stylesheet" href="css/bundle.css" />
  </head>
  <body>
    <div id="app"></div>
    <script src="scripts/bundle.js"></script>
  </body>
</html>


src/about/aboutPage.js
----
"use strict";

var React = require('react');

var Home = React.createClass({
  render: function() {
    return (
      <div className="jumbotron">
        <h1>About</h1>
        <p>
          This application uses the following technologies:
          <ul>
            <li>React</li>
            <li>React Router</li>
            <li>Flux</li>
            <li>Node</li>
            <li>Gulp</li>
            <li>Browserify</li>
            <li>Bootstrap</li>
          </ul>
        </p>
      </div>
    );
  }
});

module.exports = Home;


src/components/common/header.js
----
"use strict";

var React = require('react');

var Header = React.createClass({
  render: function() {
    return (
      <nav className="navbar navbar-default">
        <div className="container-fluid">
          <a href="/" className="navbar-brand">
            <img src="images/pluralsight-logo.png" />
          </a>
          <ul className="nav navbar-nav">
            <li><a href="/">Home</a></li>
            <li><a href="/#about">About</a></li>
          </ul>
        </div>
      </nav>
    );
  }
});

module.exports = Header;


src/images/pluralsight-logo.png
----


favicon.ico
----


gulpfile.js
----
...
var config = {
    ...
    paths: {
        ...
        images: './src/images/*',
        ...
    }
}
...
// Migrates images to dist folder
// Note that I could even optimize my images here
gulp.task('images', function() {
  gulp.src(config.paths.images)
    .pipe(gulp.dest(config.paths.dist + '/images'))
    .pipe(connect.reload());

  //publish favicon
  gulp.src('./src/favicon.ico')
    .pipe(gulp.dest(config.paths.dist)); // this is where browsers usually request favicon.ico from (the root of the website)
});



5. React Lifecycle
===================

* Data of React components is held in 2 places:
  - Props - this.props.username
    ~ Used to pass the data down to the child components. Look like HTML attributes, but immutable, i.e. owned by the parent.
    ~ getDefaultProps() - an optional function which can be used to define values for properties of the component in case parent component doesn't declare the values.
  - State - this.state.username
    ~ Holds mutable state of the React component.
      Strive to use it only in the Controller View, i.e. only use state on a top level component and pass data down to child components via props.
    ~ getInitialState() - an optional function which sets the initial state for the component, typically in the top level component called Controller View.
      This is the only place where it is possible to assign to this.state directly. Everywhere else this.setState() is used.

* React Component Lifecycle functions:
  - componentWillMount
    When: Before initial render, both client and server.
    Why: Good spot to set initial state.
  - componentDidMount
    When: After render, i.e. by this time the component is rendered in the DOM.
    Why: Access DOM, integrate with frameworks, set timers, AJAX requests.
  - componentWillReceiveProps
    When: When receiving new props, i.e. when properties are chaged. Not called on initial render.
    Why: Set state before the next render.
  - shouldComponentUpdate
    When: Immediately before render when the new props or state are being received. Not called on initial render.
    Why: Performance. Return false to avoid unnecessary re-renders, e.g. when the data change doesn't affect the DOM.
  - componentWillUpdate
    When: Immediately before rendering when new props or state are being received. Not called on initial render.
    Why: Prepare for an update. Can't call setState() in this function.
  - componentDidUpdate
    When: After component's updates are flushed to the DOM, i.e. when the component was re-rendered. Not called on initial render.
    Why: Work with the DOM after an update.
  - componentWillUnmount
    When: Immediately before component is removed from DOM.
    Why: Cleanup. Destroying any redundant resources or elements that were created when the component was mounted.

* Lifecycle sequences:
  - Initialization - getDefaultProps() ==> getInitialState() ==> componentWillMount() ==> render() ==> componentDidMount()
  - State changes - shouldComponentUpdate() ==> componentWillUpdate() ==> render() ==> componentDidUpdate()
  - Props changes - componentWillReceiveProps() ==> shouldComponentUpdate() ==> componentWillUpdate() ==> render() ==> componentDidUpdate()
  - Unmounting - componentWillUnmount()

* Keys for Dynamic Children - <tr key={author.id}>
  When creating multiple child components dynamically, e.g. rows in a table, you need to provide a key for each child component, which is used by React to ensure the
  other child components are properly re-ordered or destroyed. This is often the primary key for the corresponding database record, but it need not to be.


src/api/authorApi.js - http://bit.ly/authorapi
----
"use strict";

//This file is mocking a web API by hitting hard coded data.
var authors = require('./authorData').authors;
var _ = require('lodash');

//This would be performed on the server in a real app. Just stubbing in.
var _generateId = function(author) {
  return author.firstName.toLowerCase() + '-' + author.lastName.toLowerCase();
};

var _clone = function(item) {
  return JSON.parse(JSON.stringify(item)); //return cloned copy so that the item is passed by value instead of by reference
};

var AuthorApi = {
  getAllAuthors: function() {
    return _clone(authors);
  },

  getAuthorById: function(id) {
    var author = _.find(authors, {id: id});
    return _clone(author);
  },

  saveAuthor: function(author) {
    //pretend an ajax call to web api is made here
    console.log('Pretend this just saved the author to the DB via AJAX call...');

    if (author.id) {
      var existingAuthorIndex = _.indexOf(authors, _.find(authors, {id: author.id}));
      authors.splice(existingAuthorIndex, 1, author); // splice(index, how many items to remove, item n to add)
    } else {
      //Just simulating creation here.
      //The server would generate ids for new authors in a real app.
      //Cloning so copy returned is passed by value rather than by reference.
      author.id = _generateId(author);
      authors.push(author);
    }

    return _clone(author);
  },

  deleteAuthor: function(id) {
    console.log('Pretend this just deleted the author from the DB via an AJAX call...');
    _.remove(authors, { id: id});
  }
};

module.exports = AuthorApi;


src/api/authorData.js - http://bit.ly/authorapidata
----
module.exports = {
  authors:
  [
    {
      id: 'cory-house',
      firstName: 'Cory',
      lastName: 'House'
    },
    {
      id: 'scott-allen',
      firstName: 'Scott',
      lastName: 'Allen'
    },
    {
      id: 'dan-wahlin',
      firstName: 'Dan',
      lastName: 'Wahlin'
    }
  ]
};


src/components/authors/authorPage.js
----
"use strict";

var React = require('react');
var AuthorApi = require('../../api/authorApi');

var Authors = React.createClass({

  getInitialState: function() {
    return {
      authors: []
    };
  },

  componentWillMount: function() {
    this.setState({ authors: AuthorApi.getAllAuthors() });
  },

  render: function() {

    var createAuthorRow = function(author) {
      return (
        <tr>
          <td><a href={"/#authors/" + author.id}>{author.id}</a></td>
          <td>{author.firstName} {author.lastName}</td>
        </tr>
      );
    };

    return (
      <div className="jumbotron">
        <h1>Authors</h1>
        <table className="table">
          <thead>
            <th>ID</th>
            <th>Name</th>
          </thead>
          <tbody>
            {this.state.authors.map(createAuthorRow, this)}
          </tbody>
        </table>
      </div>
    );
  }
});

module.exports = Authors;


main.js
----
...
var Authors = require('./components/authors/authorPage');
...
      case 'authors' : Child = Authors; break;
...


src/components/common/header.js
----
...
            <li><a href="/#authors">Authors</a></li>
...



6. React Composition
===================

* Controller View
  - top level component
  - interacts with data stores (Flux, Redux)
  - holds the data in it's state
  - passes the state as props down to child components
  - can have nested Controller Views, but it is not recommended, since there might be multiple render() invocations
  - in other words, has to have all the "smarts" and least of "markup"
  - in this tutorial, all the *Page.js files are the Controller Views

* Prop Validation
  - Each PropTypes that isn't required, should have a corresponding field in getDefaultProps()
  - PropTypes only run in the development version of React (the non-minified one), i.e. there is a special production build of React
  - Examples:
    optionalArray: React.PropTypes.array
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.optionalObject,
    optionalString: React.PropTypes.string,
    requiredString: React.PropTypes.string.isRequired

* Mixins
  - For handling cross-cutting functionality
  - Share code between multiple components
  - 'mixins' is a special property in the React components

  - Example:

    var ManageAuthorPage = React.createClass({
      mixins: [
        Router.Navigation, // used when we want to move to another route programatically
        Router.State,
      ],
    ...
    });

  - Route.Navigation mixin is useful when we want to move to another route programatically:

    // Go to a new route
    this.transitionTo('contact')

    // Replace current route
    this.replaceWith('contact')

    // Go Back
    this.goBack()

    // Create a URL to a route
    makePath(routeName, params, query)


src/components/authors/authorList.js
----
"use strict";

var React = require('react');

var AuthorList = React.createClass({

  propTypes: {
    authors: React.PropTypes.object.isRequired
  },

  render: function() {

    var createAuthorRow = function(author) {
      return (
        <tr>
          <td><a href={"/#authors/" + author.id}>{author.id}</a></td>
          <td>{author.firstName} {author.lastName}</td>
        </tr>
      );
    };

    return (
      <div className="jumbotron">
        <table className="table">
          <thead>
            <th>ID</th>
            <th>Name</th>
          </thead>
          <tbody>
            {this.props.authors.map(createAuthorRow, this)}
          </tbody>
        </table>
      </div>
    );
  }
});

module.exports = AuthorList;


src/components/authors/authorPage.js
----
"use strict";

var React = require('react');
var AuthorApi = require('../../api/authorApi');
var AuthorList = require('./authorList');

var AuthorPage = React.createClass({

  getInitialState: function() {
    return {
      authors: []
    };
  },

  componentDidMount: function() {
    if (this.isMounted()) {
      this.setState({ authors: AuthorApi.getAllAuthors() });
    }
  },

  render: function() {

    var createAuthorRow = function(author) {
      return (
        <tr>
          <td><a href={"/#authors/" + author.id}>{author.id}</a></td>
          <td>{author.firstName} {author.lastName}</td>
        </tr>
      );
    };

    return (
      <div className="jumbotron">
        <h1>Authors</h1>
        <AuthorList authors={this.state.authors} />
      </div>
    );
  }
});

module.exports = AuthorPage;



7. React Router
===================

* Purpose is to split the application into multiple client rendered pages with deep linking.

* Route configuration:
  - Route - Declaratively map a route
  - DefaultRoute - For URL of "/". Like "index.html"
  - NotFoundRoute - Client-side 404
  - Redirect - Redirect to another route

* Lifecycle:
  - main.js engages the react-router together with the routes specified in routes.js.
    The anonymous callback function supplied specifies where in the DOM to attach the contents of the routed page (root route together with sub-route).
  - routes.js specifies the root of routes, which is app.js. Then specifies the sub-routes, which are engaged together with root route as page and sub-page.
  - app.js specifies how the routed content is attached via RouteHandler.

* Params and Querystrings:

  // Given a route like this
  <route path="/course/:courseId" handler={course} />

  // and URL like this:
  /course/clean-code?module=3

  // The component's props will be populated
  var Course = React.createClass({
    render: function() {
      this.props.params.courseId; // "clean-code"
      this.props.query.module; // "3"
      this.props.path; // "/course/clean-code?module=3"
    }
  });

* Links - a handy abstraction over anchores:
  URL:    /user/1
  Route:  <route name="user" path="/user/:userId" />
  JSX:    <Link to="user" params={{userId: 1}}>Bobby Tables</Link>
          The above Link points to Route by name "user" and passes to it the JSON object supplying placeholder values to generate HTML like:
          <a href="/user/1">Bobby Tables</a>

* Redirects - in case the URL is changed at some point, but we want to handle the situation:
  Alias Redirect:     var Redirect = Router.Redirect;
  Create a new route: <Redirect from="old-path" to="name-of-new-path" />

* Handling Transitions:
  - willTransitionTo - Determines if page should be transitioned to. Good place to check if the user is authenticated.
    If not - we may choose to abort user transitioning to the page.
  - willTransitionFrom - Run checks before user navigates away. Good place to check whether the form has any unsaved data, so that the user can be prompted.
  - Example:
    var Settings = React.createClass({
      statics: {
        willTransitionTo: function(transition, params, query, callback) {
          if (!isLoggedIn) {
            transition.abort();
            callback();
          }
        },
        willTransitionFrom: function(transition, component) {
          if (component.formHasUnsavedData()) {
            if (!confirm('Sure you want to leave without saving?')) {
              transition.abort();
            }
          }
        }
      }
      // ...
    });

* Locations:
  - Hash Location (default) - yourUrl.com#/courses
    ~ (-) Ugly URLs
    ~ (+) Works in all browsers
    ~ (-) Not compatible with server-render
  - History Location - yourUrl.com/courses
    ~ (+) Clean URLs
    ~ (-) IE10+
    ~ (+) Works for server-render
    ~ (-) In order for this type of routing to work, the initial request to the website must be to the clientside index page. Can be fixed by using redirect on a webserver.
    This uses HTML5 History API's push state, replace state and pop state to change our History.


src/routes.js
----
"use strict";

var React = require('react');

var Router = require('react-router');
var DefaultRoute = Router.DefaultRoute;
var Route = Router.Route;
var NotFoundRoute = Router.NotFoundRoute;
var Redirect = Router.Redirect;

var routes = (
  <Route name="app" path="/" handler={require('./components/app')}> // this is shown for each page
    <DefaultRoute handler={require('./components/homePage')}/> // if chosen, this is shown together with the root route as a sub-route
    <Route name="authors" handler={require('./components/authors/authorPage')} />
    // 'name' is the defined name of the route that is to be used in the code while referring to the route.
    // 'path' is the part of URI that corresponds to the route. It is optional attribute that can be ommitted if it matches the 'name'.
    <Route name="about" handler={require('./components/about/aboutPage')} />
    <NotFoundRoute handler={require('./components/notFoundPage')}/>
    <Redirect from="about-us" to="about" /> // if the URL was renamed
    <Redirect from="awthurs" to="authors" /> // to handle potential typos if needed
    <Redirect from="about/*" to="about" /> 'from' can also contain special characters, like '*'
  </Route>
);

module.exports = routes;


src/components/app.js
----
/* eslint-disable strict */ //Disabling check because we can't run strict mode. Need global vars.

var React = require('react');
var Header = require('./common/header');
var RouteHandler = require('react-router').RouteHandler;

$ = jQuery = require('jquery'); // Bootstrap expects jquery to be in a global namespace

var App = React.createClass({
  render: function() {
    return (
      <div>
        <Header/>
        <div className="container-fluid">
          <RouteHandler/>
        </div>
      </div>
    );
  }
});

module.exports = App;


src/components/common/header.js
----
...
var Router = require('react-router');
var Link = Router.Link;
...
        <div className="container-fluid">
          <Link to="app" className="navbar-brand">
            <img src="images/pluralsight-logo.png" />
          </Link>
          <ul className="nav navbar-nav">
            <li><Link to="app">Home</Link></li>
            <li><Link to="authors">Authors</Link></li>
            <li><Link to="about">About</Link></li>
          </ul>
        </div>
...


src/components/notFoundPage.js
----
"use strict";

var React = require('react');
var Link = require('react-router').Link;

var NotFoundPage = React.createClass({
  render: function() {
    return (
      <div>
        <h1>Page Not Found</h1>
        <p>Whoops! Sorry, there is nothing to see here.</p>
        <p><Link to="app">Back to Home</Link></p>
      </div>
    );
  }
});

module.exports = NotFoundPage;


src/components/homePage.js
----
...
var Router = require('react-router');
var Link = Router.Link;
...
        <Link to="about" className="btn btn-primary btn-lg">Learn more</Link>
...


src/components/about/aboutPage.js
----
...
  statics: {
    willTransitionTo: function(transition, params, query, callback) {
      if (!confirm('Are you sure you want to read a page that\'s this boring?')) {
        transition.abort(); // this is fired once unless the page is reloaded...
      } else {
        callback();
      }
    },
    willTransitionFrom: function(transition, component) {
      if (!confirm('Are you sure you want to leave a page that\'s this exciting?')) {
        transition.abort();
      }
    }
  },
...


src/main.js
----
"use strict";

var React = require('react');
var Router = require('react-router');
var routes = require('./routes');

// Passing the additional Router.HistoryLocation argument switches the Location engine from Hash (default) to History (HTML5 History API)
Router.run(routes, Router.HistoryLocation, function(Handler) {
  React.render(<Handler />, document.getElementById('app'));
});



8. React Forms
===================
* Concepts to be covered:
  - Controlled components - has to have a bound value and a change handler, as otherwise the input won't register due to one-way binding.
  - Reusable inputs - created a generic React component wrapper for text inputs to reuse, which include input element, label and validation message placeholder.
  - Validation - the change handler which included in the controller view and markup included in the reusable input component.
  - Redirects - after saving the author via ReactRouter.
  - User notifications - after saving via toastr.
  - Dirty form - protection from navigation away via ReactRouter's willTransitionFrom.
  - Populating on load - via ReactRouter's componentWillMount and controlled view to call AuthorApi and set state.
  - PropTypes - protect React component API.


src/main.js
----
...
Router.run(routes, function(Handler) {
...


src/components/authors/manageAuthorPage.js
----
"use strict";

var React = require('react');
var Router = require('react-router');
var AuthorForm = require('./authorForm');
var AuthorApi = require('../../api/authorApi');
var toastr = require('toastr');

var ManageAuthorPage = React.createClass({

  mixins: [
    Router.Navigation // this is used in the saveAuthor handler for transitionTo() invocation
  ],

  statics: {
    willTransitionFrom: function(transition, component) { // this prevents from navigating away if there were changes to inputs
      if (component.state.dirty && !confirm('Leave withour saving?')) {
        transition.abort();
      }
    }
  },

  getInitialState: function() {
    return {
      author: { id: '', firstName: '', lastName: '' },
      errors: {},
      dirty: false
    };
  },

  componentWillMount: function() { // not 'componentDidMount', because we want to setState before rendering occurres
    var authorId = this.props.params.id; // from the path '/author/:id' if routed here by 'manageAuthor' route and not 'addAuthor'
    if (authorId) {
      this.setState({author: AuthorApi.getAuthorById(authorId)});
    }
  },

  // When specified as onChange event handler, this function will be called on every single key press
  setAuthorState: function(event) {
    this.setState({dirty: true}); // setting 'dirty' when any key pressed
    var field = event.target.name;
    var value = event.target.value;
    this.state.author[field] = value;
    return this.setState({author: this.state.author});
  },

  authorFormIsValid: function() {
    var formIsValid = true;
    this.state.error = {}; // clear any previous errors

    if (this.state.author.firstName.length < 2) {
      this.state.errors.firstName = 'First name must be at least 2 characters';
      formIsValid = false;
    } else {
      this.state.errors.firstName = null;
    }

    if (this.state.author.lastName.length < 2) {
      this.state.errors.lastName = 'Last name must be at least 2 characters';
      formIsValid = false;
    } else {
      this.state.errors.lastName = null;
    }

    this.setState({errors: this.state.errors});

    return formIsValid;
  },

  saveAuthor: function(event) {
    event.preventDefault(); // we don't want the default browser behavior here, i.e. we are going to use JavaScript code and not browser Submit behavior
    if (!this.authorFormIsValid()) {
      return;
    }
    AuthorApi.saveAuthor(this.state.author);
    this.setState({dirty: false}); // resetting 'dirty' flag
    toastr.success('Author Saved'); // popup feedback message
    this.transitionTo('authors'); // the Router.Navigation mixin is used here
  },

  render: function() {
    return (
      <AuthorForm
        author={this.state.author}
        onChange={this.setAuthorState}
        onSave={this.saveAuthor}
        errors={this.state.errors} />
    );
  }
});

module.exports = ManageAuthorPage;


src/routes.js
----
...
    <Route name="addAuthor" path="author" handler={require('./components/authors/manageAuthorPage')} />
    <Route name="manageAuthor" path="author/:id" handler={require('./components/authors/manageAuthorPage')} />
...


src/components/authors/authorForm.js
----
"use strict";

var React = require('react');
var Input = require('../common/textInput');

var AuthorForm = React.createClass({

  propTypes: {
    author: React.PropTypes.object.isRequired,
    onSave: React.PropTypes.func.isRequired,
    onChange: React.PropTypes.func.isRequired,
    errors: React.PropTypes.object
  },

  render: function() {
    return (
      <form>
        <h1>Manage Author</h1>
        <Input
          name="firstName"
          label="First Name"
          value={this.props.author.firstName}
          onChange={this.props.onChange}
          error={this.props.errors.firstName} />
        <Input
          name="lastName"
          label="Last Name"
          value={this.props.author.lastName}
          onChange={this.props.onChange}
          error={this.props.errors.lastName} />
        <input type="Submit" value="Save" className="btn btn-default" onClick={this.props.onSave}/>
      </form>
    );
  }
});

module.exports = AuthorForm;


src/components/common/textInput.js
----
"use strict";

var React = require('react');

var Input = React.createClass({

  propTypes: {
    name: React.PropTypes.string.isRequired,
    label: React.PropTypes.string.isRequired,
    onChange: React.PropTypes.func.isRequired,
    placeholder: React.PropTypes.string,
    value: React.PropTypes.string,
    error: React.PropTypes.string
  },

  render: function() {

    var wrapperClass = 'form-group';
    if (this.props.error && this.props.error.length > 0) {
      wrapperClass += " " + 'has-error';
    }

    return (
      <div className={wrapperClass}>
        <label htmlFor={this.props.name}>{this.props.label}</label>
        <div className="field">
          <input type="text"
            name={this.props.name}
            className="form-control"
            placeholder={this.props.placeholder}
            ref={this.props.name}
            value={this.props.value}
            onChange={this.props.onChange}
            />
          <div className="input">{this.props.error}</div>
        </div>
      </div>
    );
  }
});

module.exports = Input;


src/components/authors/authorPage.js
----
...
var Router = require('react-router');
var Link = Router.Link;
...
        <Link to="addAuthor" className="btn btn-default">Add Author</Link>
...


src/components/authors/authorList.js
----
...
var Router = require('react-router');
var Link = Router.Link;
...
          <td><Link to="manageAuthor" params={{id: author.id}}>{author.id}</Link></td>
...


gulpfile.js
----
...
var config = {
    ...
    paths: {
        ...
        css: ...
          'node_modules/toastr/toastr.css'
        ...
    }
}
...



9. Flux
===================

* Flux is not a framework, it is an architectural pattern for unidirectional data flows.
  All updates to an application state occurres in a centralized dispatcher, which dispatches the application data to the data stores.
  Flux deals with actions and data changes.

* Flux implementations - Facebook's Flux, Alt, Reflux, Flummox, Marty, Fluxxor, Delorean, Redux, NuclearJS, Fluxible.

* Unidirectional data flows explained:
  - Concept:
    Action ==> Dispatcher ==> Store ==> React View
    ~ When Action occurres, the Dispatcher notifies any stores that are registered in a dispatcher that an action has occurred.
    ~ When the Store changes, the React View is updated so that the user can see the updated UI.
    ~ When the user interacts with the UI element, a new action occurres and this unidirectional flow starts over.

* 3 core Flux concepts - closer look:

  - Actions
    ~ Encapsulate the specific events that occur in the application - save user, delete item, etc.
    ~ The Dispatcher exposes a method that allows us to trigger a dispatch to the stores and to include a payload of data which is called an Action.
    ~ Action Creators are the Dispatcher Helper Methods and they describe all the actions that are possible in the application.
    ~ Actions can be triggered in 2 different places: when user interacts with UI or from the server (page load, error occurres during calls to the server).
    ~ The action related functions are usually grouped together in files that have related actions - create course, rate course, etc.
    ~ Action Creator Methods add a Type that is stored in the Constants file.
      This type is used by a dispatcher to properly handle the action and pass updates to related Stores.
    ~ Action Payload structure - type and data:
      {
        type: USER_SAVED,
        data: {
          firstName: 'Cory',
          lastName: 'House'
        }
      }

  - Dispatcher
    ~ Acts as a Central Hub and all data flows goes through it. It is a singleton, i.e. there is only one Dispatcher per application.
    ~ Stores register with the Dispatcher so that they can be notified when the data changes, so the Dispatcher simply holds a list of callbacks.
    ~ The Dispatcher invokes the callbacks that have been registered with it and it broadcasts the payload that it receives from the Action.
    ~ Invocation of callbacks dispatches the Actions to the relevant Stores.
    ~ With Flux it is helpful to create a Constans file to keep things organized and to get a high level view on what the application does.

  - Stores
    ~ Holds application data, logic, data retrieval methods.
    ~ It is not a Model, but it contains Models.
    ~ An application can have a single store, but the the application gets larger, it is useful to have multiple.
      Usually, Stores get created for each major concept or domain in the application.
    ~ Stores get updated because they have callbacks that are registred with a Dispatcher.
    ~ Only the Stores are allowed to register dispatcher callbacks, i.e. the React component should never try to register with the dispatcher directly.
    ~ Flux stores are extended with Node's EventEmitter, which allows the Stores to both Listen to and Broadcast events.
      This also allows our React components to update based on those events, since our React components listen to our Stores.
    ~ Stores have no direct set or methods, but instead they only accept updates vis callbacks that are registered with the Dispatcher.
    ~ The Store's the only thing in an application that knows how to update the data. This is the most important part of Flux.
      The event that Dispatcher dispatches doesn't know how to add or remove items, but only the Store knows how.
    ~ The Structure of a Store:
      1. Extend EventEmitter - emitted events is a way to notify the React components that the data has changed.
      2. addChangeListener() and removeChangeListener() - expose adding and removing change listeners for the particular React component to get notified of the Store changes.
      3. emitChange() - method that actually emits the change.
    ~ Example with 3 data stores: Dispatcher ==> Payload ==> User Store / Address Store / Product Store
      In this case the Dispatcher will send the Action Payload to all 3 of these Stores in parallel.
      The Dispatcher can be used to manage dependencies between the Stores by invoking the registered callbacks in a specific order by using waitFor() API.

* Flux flow in detail:
  - Action - The flow begins when the user did something in the UI, e.g. clicked "Save User" button. Actions commonly make Ajax calls to other web API's.
  - Send Action Payload - Payload is sent to Dispatcher. Payload always has the same structure - type and data, e.g.:
                          { type: USER_SAVED, data: {firstName: 'Cory', lastName: 'House'} }
  - Dispatcher - Checks its list of registered callbacks to determine which stores should receive the Payload.
  - Send Action Payload - Sends payload to ALL registered callbacks from stores.
  - Store - Receives Payload and updates the Store's data based on Action Payload.
  - Updates storage and fires change event - Once the Store is done processing the update, it emits a change event.
  - React View - Receives change event and re-renders. Any UI activities may generate a new Action and cause this unidirectional flow to start all over again.

* A chat with Flux:
  - React      - Hey CourseAction, someone clicked this "Save Course" button.
  - Action     - Thanks React! I registered an action creator with the dispatcher, so the dispatcher should take care of notifying all the stores that care.
  - Dispatcher - Let me see who cares about course being saved. Ah! Looks like the CourseStore has registered a callback with me, so I'll let her know.
  - Store      - Hi dispatcher! Thanks for the update! I'll update my data with the payload you sent. Then I'll emitan event for the React components that care.
  - React      - Ooo! Shiny new data from the store! I'll update the UI to reflect this!

* Flux API:
  - register(function callback) - "Hey dispatcher, run me when action happen. - Store"
  - unregister(string id) - "Hey dispatcher, stop worrying about this action. - Store"
  - waitFor(array<string> id) - "Update this store first. - Store"
    A way to run callbacks in a specific order. The array holds the dispatch tokens of the callbacks that have to be completed in order for the current one to proceed.
  - dispatch(object payload) - "Hey dispatcher, tell the stores about this action. - Action"
  - isDispatching() - "I'm busy dispatching callbacks right now. - Dispatcher"

* Flux is not a Publish-Subscribe model and differs in 2 ways:
  - Every Payload is dispatched to all registered callbacks.
  - Callbacks can wait for other callbacks to complete before proceeding processing the current one.



10. Flux Demos
===================

* Delete Author lifecycle:
  1. AuthorList.deleteAuthor() - invoking AuthorActions.deleteAuthor() function
  2. AuthorActions.deleteAuthor() - dispatching DELETE_AUTHOR action
  3. AuthorStore.Dispatcher.register() - action is processed here and change is emitted
  4. AuthorPage.componentWillMount() - added a change listener to a AuthorStore that callbacks the AuthorPage._onChange()
  5. AuthorPage._onChange() - changes the state of the component.


src/dispatcher/appDispatcher.js
----
/*
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * AppDispatcher
 *
 * A singleton that operates as the central hub for application updates.
 */

var Dispatcher = require('flux').Dispatcher;

module.exports = new Dispatcher();


scr/constants/actionTypes.js
----
"use strict";

var keyMirror = require('react/lib/keyMirror'); // to avoid typing values for keys to simulate enumeration, i.e. they key is copied to the value

module.exports = keyMirror({
  INITIALIZE: null,
  CREATE_AUTHOR: null,
  UPDATE_AUTHOR: null,
  DELETE_AUTHOR: null
});


src/stores/authorStore.js
----
"use strict";

var Dispatcher = require('../dispatcher/appDispatcher');
var ActionTypes = require('../constants/actionTypes');
var EventEmitter = require('events').EventEmitter; // Broadcasts events from our stores to React components
var assign = require('object-assign'); // A way to glue multiple objects together, e.g.: assign({foo: 0}, {bar, 1}) ==> {foo: 0, bar: 1}
var _ = require('lodash');
var CHANGE_EVENT = 'change';

var _authors = []; // '_' marks that the variable is private and is not exported out of this module

// Here we are taking the empty target object ({}) and copying the properties of EventEmitter.prototype and AuthorStore to it
// in ordrer to add EventEmitter capabilities to the AuthorStore.
var AuthorStore = assign({}, EventEmitter.prototype, {

  // expose adding change listeners for the particular React component to get notified of the Store changes
  addChangeListener: function(callback) {
    this.on(CHANGE_EVENT, callback);
  },

  // expose removing change listeners for the particular React component to get notified of the Store changes
  removeChangeListener: function(callback) {
    this.removeListener(CHANGE_EVENT, callback);
  },

  // method that actually emits the change
  emitChange: function() {
    this.emit(CHANGE_EVENT);
  },

  getAllAuthors: function() {
    return _authors;
  },

  getAuthorById: function(id) {
    return _.find(_authors, {id: id});
  }
});

// The following function is called EVERY time ANY action is dispatched. This is where this pattern differs from the traditional Publish-Subscribe.
Dispatcher.register(function(action) { // The type of 'action' used here is the one defined in authorAction.js.
  switch(action.actionType) {
    case ActionTypes.INITIALIZE:
      _authors = action.initialData.authors;
      AuthorStore.emitChange();
      break;
    case ActionTypes.CREATE_AUTHOR:
      _authors.push(action.author); // We changed the store state here and this is why we are emitting the change right after,
      AuthorStore.emitChange();     // so that all the React components that are registered with this store get re-rendered.
      break;
    case ActionTypes.UPDATE_AUTHOR:
      var existingAuthor = _.find(_authors, {id: action.author.id}); // Instead of re-retrieving author here we might just save the amended object,
      var existingAuthorIndex = _.indexOf(_authors, existingAuthor); // but it is safer from the data integrity perspective to re-retrieve it.
      _authors.splice(existingAuthorIndex, 1, action.author);
      AuthorStore.emitChange();
      break;
    case ActionTypes.DELETE_AUTHOR:
      //debugger;
      _.remove(_authors, function(author) {
        return action.id === author.id;
      });
      AuthorStore.emitChange();
      break;
    default:
      // no op
  }
});

module.exports = AuthorStore;


src/actions/authorActions.js
----
"use strict";

var Dispatcher = require('../dispatcher/appDispatcher.js');
var AuthorApi = require('../api/authorApi');
var ActionTypes = require('../constants/actionTypes');

var AuthorActions = {
  createAuthor: function(author) {

    // Our mock API is synchronous, but typically we'll be making Ajax calls in places like this so we'll probably be handling
    // a some sort of a callback or using Promises right here to be able to handle the response from a web API.
    var newAuthor = AuthorApi.saveAuthor(author);

    // Hey dispatcher, go tell all the stores that an author was just created.
    Dispatcher.dispatch({
      actionType: ActionTypes.CREATE_AUTHOR,
      author: newAuthor
    });
  },

  updateAuthor: function(author) {

    var updatedAuthor = AuthorApi.saveAuthor(author);

    Dispatcher.dispatch({
      actionType: ActionTypes.UPDATE_AUTHOR,
      author: updatedAuthor
    });
  },

  deleteAuthor: function(id) {

    //debugger;

    // If we wanted to make an asynchronous call to the server here (like in the real life scenario) and show a preloader,
    // an easy way to do that would be to have a separate AUTHOR_DELETED action that fires as well.
    // I.e. fire DELETE_AUTHOR action immediately here, then invoke web API and when the call completes - fire AUTHOR_DELETED.
    AuthorApi.deleteAuthor(id);

    Dispatcher.dispatch({
      actionType: ActionTypes.DELETE_AUTHOR,
      id: id
    });
  }
};

module.exports = AuthorActions;


src/actions/initializeActions.js
----
"use strict";

var Dispatcher = require('../dispatcher/appDispatcher');
var ActionTypes = require('../constants/actionTypes');
var AuthorApi = require('../api/authorApi');

var InitializeActions = {

  initApp: function() {

    // We could have moved this code to issue the Action directly to main.js, but it is cleaner for all actions
    // to sit at one place and in case there is a need for any further application bootstrapping.
    Dispatcher.dispatch({
      actionType: ActionTypes.INITIALIZE,
      initialData: {
        authors: AuthorApi.getAllAuthors()
      }
    });
  }
};

module.exports = InitializeActions;


src/components/authors/authorList.js
----
...
var AuthorActions = require('../../actions/authorActions');
var toastr = require('toastr');
...
  // This function could have been moved to the controller view and passed down to this author list via props.
  // Judgement call based on how likely this component can be reused and in what way, i.e. if the deleteAuthor()
  // function is likely to stay the same in all occasions - there is no need to provide means to replace it.
  deleteAuthor: function(id, event) {
    event.preventDefault();
    //debugger;
    AuthorActions.deleteAuthor(id);
    toastr.success('Author Deleted');
  },
...
          <td><a href="#" onClick={this.deleteAuthor.bind(this, author.id)}>Delete</a></td>
...
            <th></th>
...


src/components/authors/manageAuthorPage.js
----
...
var AuthorActions = require('../../actions/authorActions');
var AuthorStore = require('../../stores/authorStore');
...
  componentWillMount: function() {
    ...
      this.setState({author: AuthorStore.getAuthorById(authorId)});
    ...
  },
...
  saveAuthor: function(event) {
  ...
    if (this.state.author.id) {
      AuthorActions.updateAuthor(this.state.author);
    } else {
      AuthorActions.createAuthor(this.state.author);
    }
    ...
  },
...


src/components/authors/authorPage.js
----
"use strict";

var React = require('react');
var Router = require('react-router');
var Link = Router.Link;
var AuthorStore = require('../../stores/authorStore');
var AuthorActions = require('../../actions/authorActions');
var AuthorList = require('./authorList');

var AuthorPage = React.createClass({

  getInitialState: function() {
    return {
      // No need to check if there are authors or not anymore, since we trust the store to retrieve either list of authors or an empty list.
      // Hence there is no need for the componentDidMount() function anymore as well.
      authors: AuthorStore.getAllAuthors()
    };
  },

  // Both componentWillMount() and componentWillUnmount() functions required when the store is updated, but it is needed to stay on the same page.
  // These will be used for deleting an author only, since adding/updating an author redirects us to author list page.
  componentWillMount: function() {
    AuthorStore.addChangeListener(this._onChange);
  },

  // Clean up when this component is unmounted.
  componentWillUnmount: function() {
    AuthorStore.removeChangeListener(this._onChange);
  },

  _onChange: function() {
    //debugger;
    this.setState({ authors: AuthorStore.getAllAuthors() });
  },

  render: function() {

    return (
      <div className="jumbotron">
        <h1>Authors</h1>
        <Link to="addAuthor" className="btn btn-default">Add Author</Link>
        <AuthorList authors={this.state.authors} />
      </div>
    );
  }
});

module.exports = AuthorPage;


src/main.js
----
...
var InitializeActions = require('./actions/initializeActions');

InitializeActions.initApp();
...


11. Challenge
===================
* Build Course Management section:
  - Add 'Courses' to the navigation bar between Authors and About.
  - Add a new page with list of courses with columns: Watch, Delete, Title, Author, Category, Length.
  - Create the means to add and edit courses in the similar manner as it is done for authors.
  - Create a separate store to hold course related data.
  - On the course edit page the authors needs to be a dropdown.


xxxxxxxx - http://bit.ly/courseapi
----
"use strict";

//This file is mocking a web API by hitting hard coded data.
var courses = require('./courseData').courses;
var _ = require('lodash');

//This would be performed on the server in a real app. Just stubbing in.
var _generateId = function(course) {
	return course.title.replace(' ', '-');
};

var _clone = function(item) {
	return JSON.parse(JSON.stringify(item)); //return cloned copy so that the item is passed by value instead of by reference
};

var CourseApi = {
	getAllCourses: function() {
		return _clone(courses);
	},

	getCoursesById: function(id) {
		var course = _.find(courses, {id: id});
		return _clone(course);
	},

	saveCourse: function(course) {
		console.log('Imagine saving course via AJAX call...');

		if (course.id) {
			var existingCourseIndex = _.indexOf(courses, _.find(courses, {id: course.id}));
			courses.splice(existingCourseIndex, 1, course);
		} else {
			//just simulating creation here. This data
			//would be generated on the server in a real app.
			course.id = _generateId(course);
			courses.push(_clone(course));
		}
		return course;
	},

	deleteCourse: function(id) {
		console.log('Imagine deleting course with id of ' + id + ' via AJAX call...');
		_.remove(courses, { id: id});
	}
};

module.exports = CourseApi;


xxxxxxxx - http://bit.ly/mockcoursedata
----
module.exports = {
	courses: [
		{
			id: "clean-code",
			title: "Clean Code: Writing Code for Humans",
			watchHref: "http://www.pluralsight.com/courses/writing-clean-code-humans",
			author: {
				id: "cory-house",
				name: "Cory House"
			},
			length: "3:10",
			category: "Software Practices"
		},
		{
			id: "architecture",
			title: "Architecting Applications for the Real World",
			watchHref: "http://www.pluralsight.com/courses/architecting-applications-dotnet",
			author: {
				id: "cory-house",
				name: "Cory House"
			},
			length: "2:52",
			category: "Software Architecture"
		},
		{
			id: "career-reboot-for-developer-mind",
			title: "Becoming an Outlier: Reprogramming the Developer Mind",
			watchHref: "http://www.pluralsight.com/courses/career-reboot-for-developer-mind",
			author: {
				id: "cory-house",
				name: "Cory House"
			},
			length: "2:30",
			category: "Career"
		},
		{
			id: "web-components-shadow-dom",
			title: "Web Component Fundamentals",
			watchHref: "http://www.pluralsight.com/courses/web-components-shadow-dom",
			author: {
				id: "cory-house",
				name: "Cory House"
			},
			length: "5:10",
			category: "HTML5"
		}
	]
};



Appendix A
===================

src/stores/authorStore.js - boiler plate
----
"use strict";

var Dispatcher = require('../dispatcher/appDispatcher');
var ActionTypes = require('../constants/actionTypes');
var EventEmitter = require('events').EventEmitter; // Broadcasts events from our stores to React components
var assign = require('object-assign'); // A way to glue multiple objects together, e.g.: assign({foo: 0}, {bar, 1}) ==> {foo: 0, bar: 1}
var CHANGE_EVENT = 'change';

// Here we need to glue together an empty object, AuthorStore and the EventEmitter.prototype objects
// to add EventEmitter capabilities to the AuthorStore.
var AuthorStore = assign({}, EventEmitter.prototype, {

  // expose adding change listeners for the particular React component to get notified of the Store changes
  addChangeListener: function(callback) {
    this.on(CHANGE_EVENT, callback);
  },

  // expose removing change listeners for the particular React component to get notified of the Store changes
  removeChangeListener: function(callback) {
    this.removeListener(CHANGE_EVENT, callback);
  },

  // method that actually emits the change
  emitChange: function() {
    this.emit(CHANGE_EVENT);
  }
});

// The following function is called EVERY time ANY action is dispatched.
// This is where this pattern differs from the traditional Publish-Subscribe.
Dispather.register(function(action) {
  switch(action.actionType) {

  }
});

module.exports = AuthorStore;
